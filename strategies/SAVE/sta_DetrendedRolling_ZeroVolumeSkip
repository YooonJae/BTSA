from backtesting import Strategy
import numpy as np
import pandas as pd


class TEST_1(Strategy):
    """
    Detrended Rolling Percentile Strategy (long-only)
    with optional MA level gate and liquidity filters.

    Entry:
      - residual percentile < low_threshold
      - AND (if use_ma_filter) price_now < MA(ma_n)
      - AND (if skip_zero_volume) no zero-volume bar within last `window`
      - AND (if min_avg_dollar_volume > 0) avg (Close*Volume) >= threshold
      - AND (if max_price_limit > 0) price_now <= max_price_limit

    Exit:
      - residual percentile > high_threshold
    """

    # --- Core params ---
    window = 60
    low_threshold = 0.1
    high_threshold = 0.9

    # --- MA params ---
    ma_n = 390
    use_ma_filter = False

    # --- Liquidity filters ---
    skip_zero_volume = False
    min_avg_dollar_volume = 0

    # --- Price limit filter ---
    max_price_limit = 0

    def init(self):
        price = self.data.Close
        self.percentile = self.I(self._compute_detrended_percentile, price, self.window)
        self.ma = self.I(self._rolling_mean, price, self.ma_n)

    @staticmethod
    def _rolling_mean(x: np.ndarray, n: int):
        return pd.Series(x).rolling(n, min_periods=n).mean().values

    @staticmethod
    def _compute_detrended_percentile(price: np.ndarray, window: int):
        n = len(price)
        pct = np.full(n, np.nan)
        t = np.arange(window)

        for i in range(window - 1, n):
            y = price[i - window + 1:i + 1]
            b, a = np.polyfit(t, y, 1)
            residuals = y - (a + b * t)
            pct[i] = np.mean(residuals <= residuals[-1])
        return pct

    def _entry_gate_ok(self, price_now: float) -> bool:
        if not self.use_ma_filter:
            return True
        if np.isnan(self.ma[-1]):
            return False
        return price_now < self.ma[-1]

    def _liquidity_ok(self) -> bool:
        if not self.skip_zero_volume and self.min_avg_dollar_volume <= 0:
            return True
        if len(self.data) < self.window:
            return False

        close_w = self.data.Close[-self.window:]
        vol_w   = self.data.Volume[-self.window:]

        if self.skip_zero_volume and np.any(vol_w == 0):
            return False

        if self.min_avg_dollar_volume > 0:
            avg_dollar_vol = np.nanmean(close_w * vol_w)
            if not np.isfinite(avg_dollar_vol) or avg_dollar_vol < self.min_avg_dollar_volume:
                return False

        return True

    def _price_limit_ok(self, price_now: float) -> bool:
        """Block if price exceeds user-set maximum."""
        if self.max_price_limit > 0:
            return price_now <= self.max_price_limit
        return True

    def next(self):
        p = self.percentile[-1]
        if np.isnan(p):
            return

        price_now = self.data.Close[-1]

        # Entry rule
        if (
            (p < self.low_threshold)
            and not self.position
            and self._entry_gate_ok(price_now)
            and self._liquidity_ok()
            and self._price_limit_ok(price_now)  # <-- NEW FILTER
        ):
            self.buy()

        # Exit rule
        elif (p > self.high_threshold) and self.position.is_long:
            self.position.close()