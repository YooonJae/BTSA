from backtesting import Strategy
import numpy as np
import pandas as pd


class TEST_1(Strategy):
    """
    Detrended Rolling Percentile Strategy (long-only)
    with optional MA level gate and a price ceiling.

    Detrending: rolling polynomial (non-linear). Default: quadratic (degree=2)

    Entry:
      - residual percentile < low_threshold
      - AND (if use_ma_filter)  price_now < MA(ma_n)
      - AND price_now <= max_price * (1 - price_buffer_pct)

    Exit:
      - residual percentile > high_threshold
      - OR price_now >= max_price   (hard ceiling exit)
    """

    # --- Core params ---
    window = 3900
    low_threshold = 0.1
    high_threshold = 0.9

    # --- Nonlinear detrend params ---
    detrend_degree = 4  # 2=quadratic; can set to 3 for cubic, etc.

    # --- MA (level) gate ---
    ma_n = 390
    use_ma_filter = False  # require price < MA?

    # --- Price ceiling ---
    max_price = 20000.0
    price_buffer_pct = 0.005
    cooldown_bars = 0

    def init(self):
        price = self.data.Close
        self.percentile = self.I(
            self._detrended_percentile_poly, price, self.window, self.detrend_degree
        )
        self.ma = self.I(self._rolling_mean, price, self.ma_n)
        self._cooldown = 0

    @staticmethod
    def _rolling_mean(x, n):
        return pd.Series(x).rolling(n, min_periods=n).mean().values

    @staticmethod
    def _detrended_percentile_poly(price, window, degree):
        n = len(price)
        pct = np.full(n, np.nan)
        degree = int(degree)

        # Need at least degree+1 points to fit
        min_pts = max(window, degree + 1)

        # Scale time to [-1, 1] to improve polyfit conditioning
        t = np.linspace(-1.0, 1.0, window)

        for i in range(min_pts - 1, n):
            y = price[i - window + 1:i + 1]
            # Fit polynomial of given degree and remove trend
            coeffs = np.polyfit(t, y, degree)
            trend = np.polyval(coeffs, t)
            resid = y - trend

            now = resid[-1]
            pct[i] = np.mean(resid <= now)  # percentile of current residual

        return pct

    def _entry_gate_ok(self, price_now):
        if not self.use_ma_filter:
            return True
        if np.isnan(self.ma[-1]):
            return False
        return price_now > self.ma[-1]

    def next(self):
        p = self.percentile[-1]
        if np.isnan(p):
            return

        price_now = self.data.Close[-1]

        # Hard ceiling exit
        if self.position.is_long and price_now >= self.max_price:
            self.position.close()
            if self.cooldown_bars > 0:
                self._cooldown = self.cooldown_bars
            return

        # Cooldown countdown
        if self._cooldown > 0:
            self._cooldown -= 1
            return

        # Block entries too close to ceiling
        if price_now > self.max_price * (1 - self.price_buffer_pct):
            return

        # Entries & exits
        if (p < self.low_threshold) and not self.position and self._entry_gate_ok(price_now):
            self.buy()
        elif (p > self.high_threshold) and self.position.is_long:
            self.position.close()